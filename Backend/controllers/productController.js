import Product from "../models/Product.js";

// ==========================================
// 1. ADD PRODUCT (Fixed for New Schema)
// ==========================================
export const addProduct = async (req, res) => {
  try {
    // 1. Destructure incoming data from request
    const {
      name,
      description,
      brand,
      selling_price,
      mrp,
      category_main,
      category_sub,
      stock,
      specifications,
      tags,
      is_featured
    } = req.body;

    // 2. Validate Required Fields
    if (!name || !selling_price || !category_main) {
      return res.status(400).json({
        message: "Name, Selling Price, and Category are required"
      });
    }

    // 3. Construct the Product Data Object
    const productData = {
      name: name.trim(),
      description: description?.trim() || "",
      brand: brand || "Generic",

      // Pricing structure
      pricing: {
        selling_price: Number(selling_price),
        mrp: mrp ? Number(mrp) : Number(selling_price)
      },

      // Category structure
      category: {
        main: category_main,
        main_slug: "", // Will be auto-generated by middleware
        sub: category_sub || "",
        sub_slug: "" // Will be auto-generated by middleware
      },

      // Stock
      stock: Number(stock) || 0,

      // Handle Images (Multer)
      images: req.files && req.files.length > 0
        ? req.files.map((f) => f.path)
        : ["https://via.placeholder.com/400?text=No+Image"],

      // Tags
      tags: tags ? (Array.isArray(tags) ? tags : tags.split(',').map(t => t.trim())) : [],

      // Featured flag
      is_featured: is_featured === 'true' || is_featured === true || false
    };

    // 4. Handle Specifications (Parse JSON string if needed)
    if (specifications) {
      try {
        const specs = typeof specifications === 'string'
          ? JSON.parse(specifications)
          : specifications;

        productData.specifications = specs.map(s => ({
          key: s.key,
          value: s.value
        }));
      } catch (e) {
        console.error("Spec parsing error", e);
      }
    }

    // 5. Save to DB (Triggers Middleware for Slugs & Discount Calc)
    const newProduct = new Product(productData);
    await newProduct.save();

    res.status(201).json({
      success: true,
      message: "Product added successfully",
      product: newProduct
    });

  } catch (err) {
    res.status(500).json({
      success: false,
      message: "Failed to add product",
      error: err.message
    });
  }
};

// ==========================================
// 2. GET SELLER PRODUCTS (Fixed)
// ==========================================
export const getSellerProducts = async (req, res) => {
  try {
    // Use .lean() for faster read performance
    const products = await Product.find({ is_deleted: false })
      .sort({ createdAt: -1 })
      .lean();

    res.status(200).json({
      success: true,
      count: products.length,
      products
    });

  } catch (err) {
    res.status(500).json({
      success: false,
      message: "Failed to fetch products",
      error: err.message
    });
  }
};

// ==========================================
// 3. BULK IMPORT (Fixed Logic)
// ==========================================
export const bulkImportProducts = async (req, res) => {
  try {
    const { products } = req.body;

    if (!Array.isArray(products) || products.length === 0) {
      return res.status(400).json({ message: "No products provided" });
    }

    let successCount = 0;
    const errors = [];

    // Use Loop to trigger Pre-Save Middleware (Slugs/Discount Calc)
    for (let i = 0; i < products.length; i++) {
      const p = products[i];
      try {
        const newProduct = new Product({
          name: p.name,
          description: p.description || "",
          brand: p.brand || "Generic",

          pricing: {
            selling_price: Number(p.selling_price),
            mrp: p.mrp ? Number(p.mrp) : Number(p.selling_price)
          },

          category: {
            main: p.category_main,
            main_slug: "", // Auto-generated
            sub: p.category_sub || "",
            sub_slug: "" // Auto-generated
          },

          stock: Number(p.stock) || 0,
          images: p.images || ["https://via.placeholder.com/400?text=No+Image"],
          tags: p.tags || []
        });

        await newProduct.save();
        successCount++;

      } catch (err) {
        errors.push({ row: i + 1, error: err.message });
      }
    }

    res.status(200).json({
      success: true,
      imported: successCount,
      errors
    });

  } catch (err) {
    res.status(500).json({
      success: false,
      message: "Bulk import failed",
      error: err.message
    });
  }
};


export const updateProduct = async (req, res) => {
  try {
    const { productId } = req.params;

    // Find product by ID
    const product = await Product.findById(productId);

    if (!product) {
      return res.status(404).json({ message: "Product not found" });
    }

    // Destructure body
    const {
      name, description, brand,
      selling_price, mrp,
      category_main, category_sub,
      stock,
      specifications,
      tags,
      is_featured
    } = req.body;

    // Update Basic Fields
    if (name) product.name = name.trim();
    if (description !== undefined) product.description = description.trim();
    if (brand) product.brand = brand;

    // Update Pricing (Handle nested)
    if (selling_price) product.pricing.selling_price = Number(selling_price);
    if (mrp) product.pricing.mrp = Number(mrp);

    // Update Category (Triggers slug middleware on save)
    if (category_main) product.category.main = category_main;
    if (category_sub !== undefined) product.category.sub = category_sub;

    // Update Stock
    if (stock !== undefined) product.stock = Number(stock);

    // Update Tags
    if (tags !== undefined) {
      product.tags = Array.isArray(tags) ? tags : tags.split(',').map(t => t.trim());
    }

    // Update Featured Flag
    if (is_featured !== undefined) {
      product.is_featured = is_featured === 'true' || is_featured === true;
    }

    // Update Specifications
    if (specifications) {
      try {
        const specs = typeof specifications === 'string' ? JSON.parse(specifications) : specifications;
        product.specifications = specs.map(s => ({
          key: s.key,
          value: s.value
        }));
      } catch (e) {
        console.error("Spec parsing error during update", e);
      }
    }

    // If new images are uploaded, replace them
    if (req.files && req.files.length > 0) {
      product.images = req.files.map((f) => f.path);
    }

    await product.save(); // Triggers pre-save hooks (Slugs, Discount Calc)

    res.status(200).json({
      success: true,
      message: "Product updated successfully",
      product
    });

  } catch (err) {
    res.status(500).json({
      success: false,
      message: "Failed to update product",
      error: err.message
    });
  }
};

// ==========================================
// 5. DELETE PRODUCT (Soft Delete)
// ==========================================
export const deleteProduct = async (req, res) => {
  try {
    const { productId } = req.params;

    // Soft delete: Find and update is_deleted flag
    const product = await Product.findByIdAndUpdate(
      productId,
      { is_deleted: true },
      { new: true }
    );

    if (!product) {
      return res.status(404).json({ message: "Product not found" });
    }

    res.status(200).json({
      success: true,
      message: "Product moved to trash"
    });

  } catch (err) {
    res.status(500).json({
      success: false,
      message: "Failed to delete product",
      error: err.message
    });
  }
};

// ==========================================
// 6. GET PRODUCTS FOR CUSTOMERS (PAGINATED)
// ==========================================
export const getProductsForCustomers = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = 12;
    const skip = (page - 1) * limit;

    const products = await Product.find({ is_deleted: false })
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .lean();

    const totalProducts = await Product.countDocuments({ is_deleted: false });
    const totalPages = Math.ceil(totalProducts / limit);

    res.status(200).json({
      success: true,
      products,
      currentPage: page,
      totalPages,
      totalProducts
    });

  } catch (err) {
    res.status(500).json({
      success: false,
      message: "Failed to fetch products",
      error: err.message
    });
  }
};

// ==========================================
// 7. FILTER PRODUCTS FOR CUSTOMERS
// ==========================================
export const filterProductsForCustomers = async (req, res) => {
  try {
    const {
      minPrice,
      maxPrice,
      brands,
      categories,
      tags,
      minRating,
      page = 1
    } = req.query;

    const limit = 12;
    const skip = (page - 1) * limit;

    // Build filter query
    const filter = { is_deleted: false };

    if (minPrice || maxPrice) {
      filter['pricing.selling_price'] = {};
      if (minPrice) filter['pricing.selling_price'].$gte = Number(minPrice);
      if (maxPrice) filter['pricing.selling_price'].$lte = Number(maxPrice);
    }

    if (brands) {
      const brandArray = brands.split(',');
      filter.brand = { $in: brandArray };
    }

    if (categories) {
      const categoryArray = categories.split(',');
      filter['category.main'] = { $in: categoryArray };
    }

    if (tags) {
      const tagArray = tags.split(',');
      filter.tags = { $in: tagArray };
    }

    const products = await Product.find(filter)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .lean();

    const totalProducts = await Product.countDocuments(filter);
    const totalPages = Math.ceil(totalProducts / limit);

    res.status(200).json({
      success: true,
      products,
      currentPage: parseInt(page),
      totalPages,
      totalProducts
    });

  } catch (err) {
    res.status(500).json({
      success: false,
      message: "Failed to filter products",
      error: err.message
    });
  }
};
